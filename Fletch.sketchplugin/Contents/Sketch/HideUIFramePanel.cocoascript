

var showHideUIFramePanel = function (context) {

  @import 'Fletch.framework/FletchSketchHelper.js'
  @import 'Libraries/MochaJSDelegate.js'
  @import 'Libraries/ga.js'

  //如果有有界面的画板，则开始初始化面板
  //存储线程标识符，避免弹出多个面板
  var threadDictionary = NSThread.mainThread().threadDictionary();
  var identifier = "com.flyme.uxd.pbb.sketch-helper.hideUIFramePanel";

  //如果已经存在了面板，则直接退出
  if (threadDictionary[identifier]) return;
  
  //获取画板
  var selectedArtboards = prepareSelectedArtboards(context);
  var artboardsToProcess = [];
  if (selectedArtboards.length == 0) {
    artboardsToProcess = context.document.currentPage().artboards()
  } else {
    artboardsToProcess = selectedArtboards;
  }

  //筛选出有界面的画板，并提取出框架、界面名称及说明
  var artboardsWithUIFrame = [];
  for (var i = 0; i < artboardsToProcess.length; i++) {
    for (var j = 0; j < artboardsToProcess[i].layers().length; j++){
      if (artboardsToProcess[i].layers()[j].name() == "框架"){
        artboardsWithUIFrame.push(artboardsToProcess[i]);
      }
    }
  }

  //以下三个为二维数组，子数组为每个有界面的画板下相应元素的数组
  var frameLayers = [];
  var uiNameLayers = [];
  var uiDescriptionLayers = [];
  for (var i = 0; i < artboardsWithUIFrame.length; i++) {
    for (var j = 0; j < artboardsWithUIFrame[i].layers().length; j++){
      if (artboardsWithUIFrame[i].layers()[j].name() == "框架"){
      	while (frameLayers.length <= i) {
      		frameLayers.push([]);
      	}
        for (var k = 0; k < artboardsWithUIFrame[i].layers()[j].layers().length; k++){
         	frameLayers[i].push(artboardsWithUIFrame[i].layers()[j].layers()[k]);
        }
        continue;
      }
      if (artboardsWithUIFrame[i].layers()[j].name() == "界面名称"){
        for (var k = 0; k < artboardsWithUIFrame[i].layers()[j].layers().length; k++){
        	if (artboardsWithUIFrame[i].layers()[j].layers()[k].isMemberOfClass(MSTextLayer)){
        		while (uiDescriptionLayers.length <= i) {
        			uiDescriptionLayers.push([]);
        		}
        		uiDescriptionLayers[i].push(artboardsWithUIFrame[i].layers()[j].layers()[k]);
        	} else {
        		while (uiNameLayers.length <= i) {
        			uiNameLayers.push([]);
        		}
				uiNameLayers[i].push(artboardsWithUIFrame[i].layers()[j].layers()[k]);
        	}
         }
        continue;
      }
    }
  }

  //获取信息之后取消选择，方便下一步选择操作
  context.document.currentPage().changeSelectionBySelectingLayers(nil);

  //如果没有有界面的画板，则直接退出
  if(artboardsWithUIFrame.length == 0){
    [NSApp displayDialog: "框架的图层组名须为“框架”，界面名称及说明的图层组名须为“界面名称”" withTitle: "未找到包含界面框的画板"];
    return;
  }

  //初始化 GA
  var ga = new Analytics(context);

  //定义 Delegate 所需要的方法
  COScript.currentCOScript().setShouldKeepAround_(true);
  var hideUIFramePanelDelegate = new MochaJSDelegate();
  hideUIFramePanelDelegate.setHandlerForSelector("didClickFinishOperationInWindowController:", function(hideUIFramePanelWC){
    //TO DO: 面板里按钮调用的方法
    log("finish operation" + hideUIFramePanelWC.toString());
    //generateHistory (overviewArtboard, addHistoryWC, userInfo, ga);
  });

  //生成弹出的面板，设定 Delegate
  var hideUIFramePanelWC = [[ShowHideUIFrameWindowController alloc] initWithWindowNibName:@"ShowHideUIFrameWindowController"];
  hideUIFramePanelWC.delegate = (hideUIFramePanelDelegate.getClassInstance());
  [hideUIFramePanelWC showWindow:self];

  //关闭面板后需要移除对面板的引用
  var closeButton = [hideUIFramePanelWC window].standardWindowButton(NSWindowCloseButton);
  closeButton.setCOSJSTargetFunction(function(sender){
    //TO DO: 关闭窗口后需要移除对窗口的引用
    // closeAddHistoryWindow(historyWC);
    [hideUIFramePanelWC close];
    // 移除对面板的引用
    var threadDictionary = NSThread.mainThread().threadDictionary();
    var identifier = "com.flyme.uxd.pbb.sketch-helper.hideUIFramePanel";
    threadDictionary.removeObjectForKey(identifier);
    // 停止插件运行
    COScript.currentCOScript().setShouldKeepAround_(false);
  });
  threadDictionary[identifier] = hideUIFramePanelWC;

  //根据线框、说明等位置数据生成线框
  

  for (var i = 0; i < artboardsWithUIFrame.length; i++) {
  	for (var j = 0; j < uiNameLayers[i].length; j++){
  		// 外框留出边距
  		var x = uiNameLayers[i][j].frame().x() - 10;
  		var y = uiNameLayers[i][j].frame().y() - 10;
  		//确定框的起点坐标，因为获取到的是相对父图层的坐标，所以转换成相对画板的
  		var ancestors = uiNameLayers[i][j].ancestors()
  		var parent = ancestors[ancestors.length - 1]
  		var pointRelativeToArtboard = parent.convertPoint_toLayer_(CGPointMake(x,y), artboardsWithUIFrame[i]);
  		//确定框的大小
  		var width = frameLayers[i][j].frame().width() + 10 * 2;
  		var height = uiNameLayers[i][j].frame().height() + 11 + frameLayers[i][j].frame().height() + 10 * 2;
  		//画框
  		var shapeGroup = generateRectangleWithRect(NSMakeRect(pointRelativeToArtboard.x,pointRelativeToArtboard.y,width,height), true);
  		artboardsWithUIFrame[i].addLayers([shapeGroup]);
  	}
  }
}

function prepareSelectedArtboards (context) {
  var selection = context.selection;
  
  // 提取所选画板
  var selectedArtboards = [];
  for (var i = 0; i < selection.length; i++) {
    if (selection[i].isMemberOfClass(MSArtboardGroup)) {
      selectedArtboards.push(selection[i]);
    }
  }
  return selectedArtboards;
}

function generateRectangleWithRect(nsRect, isVisible) {
	var rect   = MSRectangleShape.alloc().init();
	rect.frame = MSRect.rectWithRect(nsRect);
	var shapeGroup = MSShapeGroup.shapeWithPath(rect);
	var style  = MSStyle.alloc().init();
	var styleFill = style.addStylePartOfType(0);
	styleFill.color = MSColor.colorWithRGBADictionary({"r": 0, "g": 0, "b": 0, "a": 0.02});
	var styleBorder = style.addStylePartOfType(1);
	styleBorder.color = MSColor.colorWithRGBADictionary({"r": 0.96, "g": 0.65, "b": 0.137, "a": 1});
	styleBorder.thickness = 2;
	isVisible ? style.contextSettings().setOpacity(1) : style.contextSettings().setOpacity(0.4);
	shapeGroup.setStyle(style);
	return shapeGroup;
}

