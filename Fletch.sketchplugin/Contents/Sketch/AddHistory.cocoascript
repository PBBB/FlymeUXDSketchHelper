@import 'Fletch.framework/FletchSketchHelper.js'
@import 'Libraries/MochaJSDelegate.js'
@import 'Libraries/ga.js'

var addHistory = function (context) {

  // 存储线程标识符，避免弹出多个窗口
  var threadDictionary = NSThread.mainThread().threadDictionary();
  var identifier = "com.flyme.uxd.pbb.sketch-helper.addHistory";

  // 如果已经存在了弹窗，则直接退出
  if (threadDictionary[identifier]) return;

  //初始化 GA
  var ga = new Analytics(context);

  var overviewArtboard = prepareOverviewArtboard(context);
  if (overviewArtboard == null){
    return;
  }

  //定义 Delegate 所需要的方法
  COScript.currentCOScript().setShouldKeepAround_(true);
  var historyDelegate = new MochaJSDelegate();
  historyDelegate.setHandlerForSelector("handleHistoryinAddHistoryWindowController:WithInfo:", function(addHistoryWC, userInfo){
    generateHistory (overviewArtboard, addHistoryWC, userInfo, ga);
  });

  //生成弹出的窗口，设定 Delegate
  var historyWC = [[AddHistoryWindowController alloc] initWithWindowNibName:@"AddHistoryWindowController"];
  historyWC.delegate = (historyDelegate.getClassInstance());
  var titleWithExtension = context.document.window().title();
  var title = titleWithExtension.substring(0, titleWithExtension.length() - 7);
  [[historyWC window] setTitle: "添加更新记录 - " + title];
  [historyWC showWindow:self];

  //关闭窗口后需要移除对窗口的引用
  var closeButton = [historyWC window].standardWindowButton(NSWindowCloseButton);
  closeButton.setCOSJSTargetFunction(function(sender){
    closeAddHistoryWindow(historyWC);
  });

  threadDictionary[identifier] = historyWC;
}

//获得概述画板，如果没有找到，或者找到多个就要求用户选择
function prepareOverviewArtboard (context) {
  var artboardsOfCurrentPage = context.document.currentPage().artboards();
  var overviewArtboardArray = [];
  for (var i = 0; i < artboardsOfCurrentPage.length; i++) {
    if (artboardsOfCurrentPage[i].name() == "概述") {
      overviewArtboardArray.push(artboardsOfCurrentPage[i]);
    }
  }

  //如果只有一个叫“概述”的画板
  if (overviewArtboardArray.length == 1) {
    return overviewArtboardArray[0];
  } else {
    //如果有超过一个，或者少于一个叫“概述”的画板，就从选择的画板里找
    var selection = context.selection;
    var selectedArtboards = [];
    for (var i = 0; i < selection.length; i++) {
      if (selection[i].isMemberOfClass(MSArtboardGroup)) {
        selectedArtboards.push(selection[i]);
      }
    }
    if (selectedArtboards.length == 1 ) {
      if (selectedArtboards[0].name() == "概述") {
        return selectedArtboards[0];
      }
    } else {
      [NSApp displayDialog: "请确保当前页面只有一个名为“概述”的画板。\n如果有多个名为“概述”的画板，你可以选中希望添加更新记录的“概述”画板，并重新添加更新记录" withTitle: "未找到可添加更新记录的画板"];
      return null;
    }
  }
}

function generateHistory (overviewArtboard, addHistoryWC, userInfo, ga) {

  //提取数据
  var updateDate = userInfo["date"];
  var author = userInfo["author"];
  var notesArray = userInfo["notes"];
  var willCombine = userInfo["willConbineHistoryOfSameDay"];

  //获取原有目录
  var historyLayerGroupsArray = [];
  var historyLayerGroup = null;
  for (var i = 0; i < overviewArtboard.layers().length; i++) {
    if (overviewArtboard.layers()[i].name() == "更新记录" && overviewArtboard.layers()[i].isMemberOfClass(MSLayerGroup)) {
      historyLayerGroup = overviewArtboard.layers()[i];
      var historyLayers = historyLayerGroup.layers();
      for (var j = 0; j < historyLayers.length; j++) {
        //目录的 children 会包含自己（好奇怪），所以需要排除（已改用 layers，不会出现奇葩情况了）
        if (historyLayers[j].isMemberOfClass(MSLayerGroup)) {
          historyLayerGroupsArray.push(historyLayers[j]);
        }
      }
      break;
    }
  }

  if (historyLayerGroup == null) {
    [NSApp displayDialog: "请确保“概述”画板里有“更新记录”图层组" withTitle: "未找到“更新记录”图层组"];
    return false;
  }

  // 将更新记录图层组按从新到旧的顺序排序
  function compareLayers (firstLayer, secondLayer) {
    if (firstLayer.frame().x() != secondLayer.frame().x()) {
      return firstLayer.frame().x() - secondLayer.frame().x();
    } else {
      return firstLayer.frame().y() - secondLayer.frame().y();
    }
  }

  historyLayerGroupsArray.sort(compareLayers);

  function generateNumberAndNotesLayersArray(notesArray) {
    //生成更新记录图层
    var updateNotesNumberLayersArray = [];
    var updateNotesLayersArray = [];

    var paragraphStyle = [[NSMutableParagraphStyle alloc] init];
    paragraphStyle.minimumLineHeight = 40;
    paragraphStyle.maximumLineHeight = 40;
    paragraphStyle.paragraphSpacing = 14;
    var attributes = {
      'NSColor' : [NSColor colorWithSRGBRed:0.29 green:0.29 blue:0.29 alpha:1],
      'NSFont' : [NSFont fontWithName: "PingFangSC-Medium" size: 24],
      'NSParagraphStyle' : paragraphStyle
    };


    for (var i = 0; i < notesArray.length; i++) {
      var numberTextLayer = MSTextLayer.new();
      numberTextLayer.setStringValue((i+1).toString() + ".");
      numberTextLayer.setStyleAttributes(attributes);
      numberTextLayer.setName((i+1).toString());
      numberTextLayer.adjustFrameToFit();
      updateNotesNumberLayersArray.push(numberTextLayer);

      var updateNoteTextLayer = MSTextLayer.new();
      updateNoteTextLayer.setStringValue(notesArray[i]);
      updateNoteTextLayer.setName(notesArray[i]);
      updateNoteTextLayer.setStyleAttributes(attributes);
      updateNoteTextLayer.setTextBehaviour(1);
      updateNoteTextLayer.frame().setWidth(492);
      updateNoteTextLayer.adjustFrameToFit();
      updateNotesLayersArray.push(updateNoteTextLayer);
    }

    return [updateNotesNumberLayersArray, updateNotesLayersArray];
  }

  //生成日期字符串（考虑时区、语言等因素，确保转换为中文日期）
  var dateFormatter = [[NSDateFormatter alloc]init];
  [dateFormatter setTimeZone: [NSTimeZone localTimeZone]];
  var locale = [[NSLocale alloc] initWithLocaleIdentifier:@"zh_CN"];
  var localeFormatString = [NSDateFormatter dateFormatFromTemplate:@"dMMM" options:0 locale:locale];
  dateFormatter.dateFormat = localeFormatString;
  var localizedString = [dateFormatter stringFromDate:updateDate];

  var latestHistoryLayersGroup = historyLayerGroupsArray[0];

  //如果历史记录为空，则直接生成新内容
  if (historyLayerGroupsArray.length == 0){
    willCombine = 0;
  } else {
    //如果最新记录与更新日期不同，则直接生成新内容
    if (latestHistoryLayersGroup.name().localeCompare(localizedString) != 0) {
      willCombine = 0;
    }
  }

  //如果不选择合并同一天记录，或者历史记录原本为空，则全部内容新生成
  if (willCombine == 0) {

    //生成新目录
    var updateHistorylayerGroup = MSLayerGroup.new();
    updateHistorylayerGroup.setName(localizedString);

    //生成日期和设计师图层
    var dateAndDesigner = localizedString;
    if (author != "") {
      dateAndDesigner = localizedString + "   " + author;
    }
    var dateAndDesignerTextLayer = MSTextLayer.new();
    dateAndDesignerTextLayer.setStringValue(dateAndDesigner);
    dateAndDesignerTextLayer.setName(dateAndDesigner);
    var font = [NSFont fontWithName: "PingFangSC-Thin" size: 38];
    dateAndDesignerTextLayer.setFont(font);
    dateAndDesignerTextLayer.textColor = MSColor.colorWithRGBADictionary({"r": 0.1, "g": 0.1, "b": 0.1, "a": 1});
    dateAndDesignerTextLayer.adjustFrameToFit();

    //生成更新记录图层
    var numberAndNotesArray = generateNumberAndNotesLayersArray(notesArray);
    var updateNotesNumberLayersArray = numberAndNotesArray[0];
    var updateNotesLayersArray = numberAndNotesArray[1];

    
    updateHistorylayerGroup.addLayers([dateAndDesignerTextLayer].concat(updateNotesNumberLayersArray).concat(updateNotesLayersArray));
    historyLayerGroupsArray.unshift(updateHistorylayerGroup);
    [historyLayerGroup insertLayer:updateHistorylayerGroup atIndex: 0];

    //调整各个图层的间距
    for (var i = 0; i < updateNotesLayersArray.length; i++) {
      updateNotesLayersArray[i].frame().setX(dateAndDesignerTextLayer.frame().x() + 33);
      if (i == 0) {
        updateNotesLayersArray[i].frame().setY(dateAndDesignerTextLayer.frame().y() + 82);
      } else {
        updateNotesLayersArray[i].frame().setY(updateNotesLayersArray[i-1].frame().y() + updateNotesLayersArray[i-1].frame().height() + 14);
      }

      updateNotesNumberLayersArray[i].frame().setX(dateAndDesignerTextLayer.frame().x());
      updateNotesNumberLayersArray[i].frame().setY(updateNotesLayersArray[i].frame().y());
    }
    updateHistorylayerGroup.resizeToFitChildrenWithOption(0);
  } else {

    //在最新的记录找到最靠后的图层，并在其下方插入生成的目录项
    var latestHistoryLayersArray = latestHistoryLayersGroup.layers();
    latestHistoryLayersArray.sort(compareLayers);
    var leftMostLayer = latestHistoryLayersArray[0];
    var bottomMostLayer = latestHistoryLayersArray[latestHistoryLayersArray.length - 1];

    //生成更新记录图层
    var numberAndNotesArray = generateNumberAndNotesLayersArray(notesArray);
    var updateNotesNumberLayersArray = numberAndNotesArray[0];
    var updateNotesLayersArray = numberAndNotesArray[1];
    
    latestHistoryLayersGroup.addLayers(updateNotesNumberLayersArray.concat(updateNotesLayersArray));

    //调整各个图层的间距
    for (var i = 0; i < updateNotesLayersArray.length; i++) {
      updateNotesLayersArray[i].frame().setX(leftMostLayer.frame().x() + 33);
      if (i == 0) {
        updateNotesLayersArray[i].frame().setY(bottomMostLayer.frame().y() + 54);
      } else {
        updateNotesLayersArray[i].frame().setY(updateNotesLayersArray[i-1].frame().y() + updateNotesLayersArray[i-1].frame().height() + 14);
      }

      //改变更新序号的数值，这里只能近似去推算
      var newNumber = parseInt(updateNotesNumberLayersArray[i].name()) + Math.floor((latestHistoryLayersArray.length - 1) / 2 - updateNotesLayersArray.length);
      updateNotesNumberLayersArray[i].setName(newNumber.toString());
      updateNotesNumberLayersArray[i].setStringValue(newNumber.toString() + ".");
      updateNotesNumberLayersArray[i].frame().setX(leftMostLayer.frame().x());
      updateNotesNumberLayersArray[i].frame().setY(updateNotesLayersArray[i].frame().y());
    }
    latestHistoryLayersGroup.resizeToFitChildrenWithOption(0);
  }

  // 排列目录
  var currentColumnNumber = 1;
  var maxColumnNumber = 2;
  var hasTooManyHistory = false;
  for (var i = 0; i < historyLayerGroupsArray.length; i++) {
    historyLayerGroupsArray[i].isVisible = true;
    if (i == 0) {
      historyLayerGroupsArray[i].frame().setX(0);
      historyLayerGroupsArray[i].frame().setY(229);
      var farestBottom = historyLayerGroupsArray[i].frame().y() + historyLayerGroupsArray[i].frame().height();
      if (farestBottom > 1540) {
        if (willCombine == 0) {
          //如果不是合并后过长，则删除被添加的目录并提示，弹窗不关闭
          historyLayerGroupsArray[i].removeFromParent();
          var alert = [[NSAlert alloc] init];
          [alert setMessageText:"更新记录过长"];
          [alert setInformativeText:"请手动添加更新记录"];
          [alert addButtonWithTitle:"确定"];
          [alert beginSheetModalForWindow:[addHistoryWC window] completionHandler:nil];
          // [NSApp displayDialog: "请手动添加更新记录" withTitle: "更新记录过长"];
        } else {
          //如果是合并后过长，因为单列过长难处理，所以直接排；后续目录正常排列，弹窗关闭
          closeAddHistoryWindow(addHistoryWC);
          // [NSApp displayDialog: "请手动调整更新记录" withTitle: "更新记录过长"];
        }
      }
    } else {
      if (currentColumnNumber > maxColumnNumber) {
        historyLayerGroupsArray[i].isVisible = false;
        hasTooManyHistory = true;
        continue;
      }
      historyLayerGroupsArray[i].frame().setX(0 + 688 * (currentColumnNumber - 1));
      historyLayerGroupsArray[i].frame().setY(historyLayerGroupsArray[i-1].frame().y() + historyLayerGroupsArray[i-1].frame().height() + 154);
      var farestBottom = historyLayerGroupsArray[i].frame().y() + historyLayerGroupsArray[i].frame().height();
      if (farestBottom > 1540) {
          currentColumnNumber += 1;
          if (currentColumnNumber > maxColumnNumber) {
            historyLayerGroupsArray[i].isVisible = false;
            hasTooManyHistory = true;
            continue;
          }
          historyLayerGroupsArray[i].frame().setX(0 + 688 * (currentColumnNumber - 1));
          historyLayerGroupsArray[i].frame().setY(229);
          farestBottom = historyLayerGroupsArray[i].frame().y() + historyLayerGroupsArray[i].frame().height();
          if (farestBottom > 1540) {
            // 理论上不会出现这种情况
            historyLayerGroupsArray[i].isVisible = false;
            [NSApp displayDialog: "请手动编辑更新记录" withTitle: "更新记录过长"];
            currentColumnNumber = maxColumnNumber + 1;
          }
      }
    }
  }

  historyLayerGroup.resizeToFitChildrenWithOption(0);
  
  if (hasTooManyHistory) {
    //获取是否选择过不再提醒
    var kTooManyHistoryHidingNofityKey = 'kTooManyHistoryHidingNofity';
    var willNotify = NSUserDefaults.standardUserDefaults().objectForKey(kTooManyHistoryHidingNofityKey);
    if (willNotify != 1) {
      var alert = [[NSAlert alloc] init];
      [alert setMessageText:"更新记录添加成功"];
      [alert setInformativeText:"由于更新记录过多，较旧的更新记录已被隐藏"];
      [alert addButtonWithTitle:"确定"];
      [[alert suppressionButton] setTitle:"不再提醒"];
      alert.showsSuppressionButton = true;
      [alert runModal];
      if ([[alert suppressionButton] state] == NSOnState) {
        NSUserDefaults.standardUserDefaults().setObject_forKey(true, kTooManyHistoryHidingNofityKey);
      }
    }
 
    // [NSApp displayDialog: "由于更新记录过多，较旧的更新记录已被隐藏" withTitle: "更新记录添加成功"];
    ga.sendEvent('AddHistory', 'Success', 'TooManyHistory', notesArray.length);
    closeAddHistoryWindow(addHistoryWC);
  } else {
    ga.sendEvent('AddHistory', 'Success', 'Success', notesArray.length);
    // 这里的提示暂时去掉，因为成功的结果很明显，不需要单独的提示
    // context.document.showMessage("更新记录添加成功");
    closeAddHistoryWindow(addHistoryWC);
  }
}

function closeAddHistoryWindow (addHistoryWC){
  [addHistoryWC close];

  // 移除对窗口的引用
  var threadDictionary = NSThread.mainThread().threadDictionary();
  var identifier = "com.flyme.uxd.pbb.sketch-helper.addHistory";
  threadDictionary.removeObjectForKey(identifier);

  // 停止插件运行
  COScript.currentCOScript().setShouldKeepAround_(false);
}